// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: refund.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

///**
///退款接口

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public struct Order_V1_ReasonApi {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///退款原因类型：customer：顾客原因；admin：管理员退款；system：系统原因
  public var type: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Order_V1_Reasons {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var reason: [Order_V1_Reason] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Order_V1_Reason {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///退款id
  public var reasonID: Int32 = 0

  ///退款原因
  public var reason: String = String()

  ///英文退款原因
  public var reasonEn: String = String()

  ///日文退款原因
  public var reasonJa: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Order_V1_AuditApiCreate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///退款id
  public var orderRefundID: Int64 = 0

  ///审核状态 审核状态：auditing-审核中，audit_fail-审核失败，audit_success-审核成功
  public var auditStatus: String = String()

  ///附加信息
  public var additionData: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Order_V1_Audit {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Order_V1_RefundApiList {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 通过主订单id获取退款详情
  public var orderID: [Int64] = []

  /// 通过退款id获取退款详情
  public var orderRefundID: [Int64] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 退款订单响应参数，列表。
public struct Order_V1_RefundList {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 退款列表
  public var refundList: [Order_V1_Refund] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 部分退款请求参数
public struct Order_V1_PartRefundApiCreate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 主订单ID
  public var orderID: Int64 = 0

  ///子订单信息
  public var subOrder: [Order_V1_PartRefundSubOrderApiCreate] = []

  ///退款id，为空时由订单系统生成
  public var orderRefundID: Int64 = 0

  /// 退款备注
  public var remark: String = String()

  /// 退款原因ID 需要退款原因表
  public var reasonID: [Int32] = []

  ///附加信息
  public var additionData: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Order_V1_PartRefundSubOrderApiCreate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///子订单ID
  public var subOrderID: Int64 = 0

  /// 商品项ID  需要校验这些商品项是否为同一个子订单
  public var orderGoodsID: [Int64] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Order_V1_FullRefundApiCreate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 主订单ID
  public var orderID: Int64 = 0

  ///子订单ID
  public var subOrderID: [Int64] = []

  ///退款id，为空时由订单系统生成
  public var orderRefundID: Int64 = 0

  /// 退款备注
  public var remark: String = String()

  /// 退款原因ID 需要退款原因表
  public var reasonID: [Int32] = []

  ///附加信息
  public var additionData: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 退款响应参数
public struct Order_V1_Refund {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///主订单ID
  public var orderID: Int64 {
    get {return _storage._orderID}
    set {_uniqueStorage()._orderID = newValue}
  }

  ///退款子订单
  public var refundSubOrders: [Order_V1_RefundSubOrder] {
    get {return _storage._refundSubOrders}
    set {_uniqueStorage()._refundSubOrders = newValue}
  }

  ///货币符号
  public var currency: String {
    get {return _storage._currency}
    set {_uniqueStorage()._currency = newValue}
  }

  ///退款ID
  public var orderRefundID: Int64 {
    get {return _storage._orderRefundID}
    set {_uniqueStorage()._orderRefundID = newValue}
  }

  ///业务类型 外卖:ordering
  public var biz: String {
    get {return _storage._biz}
    set {_uniqueStorage()._biz = newValue}
  }

  public var countryID: Int32 {
    get {return _storage._countryID}
    set {_uniqueStorage()._countryID = newValue}
  }

  public var cityID: Int32 {
    get {return _storage._cityID}
    set {_uniqueStorage()._cityID = newValue}
  }

  public var userID: Int32 {
    get {return _storage._userID}
    set {_uniqueStorage()._userID = newValue}
  }

  public var uid: String {
    get {return _storage._uid}
    set {_uniqueStorage()._uid = newValue}
  }

  ///退款状态: 退款中-refunding, 已退款-refunded
  public var refundStatus: String {
    get {return _storage._refundStatus}
    set {_uniqueStorage()._refundStatus = newValue}
  }

  ///审核状态：auditing-审核中，audit_fail-审核失败，audit_success-审核成功
  public var auditStatus: String {
    get {return _storage._auditStatus}
    set {_uniqueStorage()._auditStatus = newValue}
  }

  public var refundAmount: Double {
    get {return _storage._refundAmount}
    set {_uniqueStorage()._refundAmount = newValue}
  }

  /// 退款支付手续费
  public var refundUserTransactionFee: Double {
    get {return _storage._refundUserTransactionFee}
    set {_uniqueStorage()._refundUserTransactionFee = newValue}
  }

  public var remark: String {
    get {return _storage._remark}
    set {_uniqueStorage()._remark = newValue}
  }

  public var refundSuccessTime: Int64 {
    get {return _storage._refundSuccessTime}
    set {_uniqueStorage()._refundSuccessTime = newValue}
  }

  public var refundSuccessTimeLocal: String {
    get {return _storage._refundSuccessTimeLocal}
    set {_uniqueStorage()._refundSuccessTimeLocal = newValue}
  }

  ///退款附加费
  public var refundAdditionFee: [Order_V1_RefundOrderAdditionFee] {
    get {return _storage._refundAdditionFee}
    set {_uniqueStorage()._refundAdditionFee = newValue}
  }

  ///退款优惠费
  public var refundDiscountFee: [Order_V1_RefundOrderDiscountFee] {
    get {return _storage._refundDiscountFee}
    set {_uniqueStorage()._refundDiscountFee = newValue}
  }

  ///退款申请时间
  public var createdAt: Int64 {
    get {return _storage._createdAt}
    set {_uniqueStorage()._createdAt = newValue}
  }

  ///退款申请本地时间
  public var createdAtLocal: String {
    get {return _storage._createdAtLocal}
    set {_uniqueStorage()._createdAtLocal = newValue}
  }

  ///附加信息
  public var additionData: String {
    get {return _storage._additionData}
    set {_uniqueStorage()._additionData = newValue}
  }

  ///退款审核附加信息
  public var auditAdditionData: String {
    get {return _storage._auditAdditionData}
    set {_uniqueStorage()._auditAdditionData = newValue}
  }

  /// 退款原因
  public var reason: [Order_V1_Reason] {
    get {return _storage._reason}
    set {_uniqueStorage()._reason = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Order_V1_RefundSubOrder {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var subOrderID: Int64 = 0

  ///退款ID
  public var orderRefundID: Int64 = 0

  ///退款状态: 退款中-refunding, 已退款-refunded
  public var refundStatus: String = String()

  ///退款金额
  public var refundAmount: Double = 0

  public var remark: String = String()

  public var refundSuccessTime: Int64 = 0

  public var refundSuccessTimeLocal: String = String()

  public var refundItems: [Order_V1_RefundOrderItem] = []

  ///退款附加费
  public var refundAdditionFee: [Order_V1_RefundOrderAdditionFee] = []

  ///退款优惠费
  public var refundDiscountFee: [Order_V1_RefundOrderDiscountFee] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 退款订单项信息
public struct Order_V1_RefundOrderItem {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///退款ID
  public var orderRefundID: Int64 = 0

  ///退款订单项ID
  public var orderItemID: Int64 = 0

  ///商品名称
  public var itemName: String = String()

  ///退款状态: 退款中-refunding, 已退款-refunded
  public var refundStatus: String = String()

  ///退款金额
  public var refundAmount: Double = 0

  public var remark: String = String()

  ///退款成功 UTC 时间戳
  public var refundSuccessTime: Int64 = 0

  ///退款成功本地时间
  public var refundSuccessTimeLocal: String = String()

  ///退款商品项列表
  public var refundGoods: [Order_V1_RefundOrderGoods] = []

  ///退款附加费
  public var refundAdditionFee: [Order_V1_RefundOrderAdditionFee] = []

  ///退款优惠费
  public var refundDiscountFee: [Order_V1_RefundOrderDiscountFee] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 退款商品项信息
public struct Order_V1_RefundOrderGoods {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///退款ID
  public var orderRefundID: Int64 = 0

  ///退款商品项ID
  public var orderGoodsID: Int64 = 0

  ///商品项ID
  public var goodsID: String = String()

  ///业务方商品项id
  public var bizOrderGoodsID: String = String()

  ///商品项名称
  public var goodsName: String = String()

  ///退款状态: 退款中-refunding, 已退款-refunded
  public var refundStatus: String = String()

  ///退款总金额
  public var refundAmount: Double = 0

  ///退款原始金额
  public var refundOriginAmount: Double = 0

  ///用户退款手续费
  public var refundUserTransactionFee: Double = 0

  public var remark: String = String()

  ///退款成功 UTC 时间戳
  public var refundSuccessTime: Int64 = 0

  ///退款成功本地时间
  public var refundSuccessTimeLocal: String = String()

  ///退款附加费
  public var refundAdditionFee: [Order_V1_RefundOrderAdditionFee] = []

  ///退款优惠费
  public var refundDiscountFee: [Order_V1_RefundOrderDiscountFee] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 附加费信息响应数据
public struct Order_V1_RefundOrderAdditionFee {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var title: String = String()

  ///附加费类型 tips:小费，package:打包费 etc...
  public var additionType: String = String()

  /// 主订单ID
  public var orderID: Int64 = 0

  /// 子订单ID，可选
  public var subOrderID: Int64 = 0

  /// 订单项ID
  public var orderItemID: Int64 = 0

  /// 商品项ID
  public var orderGoodsID: Int64 = 0

  /// 平台承担金额
  public var platformFee: Double = 0

  /// 商家承担金额
  public var merchantFee: Double = 0

  /// 附加费金额
  public var additionAmount: Double = 0

  ///附加信息
  public var additionData: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 优惠费信息响应数据
public struct Order_V1_RefundOrderDiscountFee {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var title: String = String()

  /// 店铺优惠-merchant_discount，平台满减-platform_discount
  public var discountType: String = String()

  /// 主订单ID
  public var orderID: Int64 = 0

  /// 子订单ID，可选
  public var subOrderID: Int64 = 0

  /// 订单项ID
  public var orderItemID: Int64 = 0

  /// 商品项ID
  public var orderGoodsID: Int64 = 0

  /// 平台承担金额
  public var platformFee: Double = 0

  /// 商家承担金额
  public var merchantFee: Double = 0

  /// 优惠金额
  public var discountAmount: Double = 0

  ///附加信息 json
  public var additionData: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "order.v1"

extension Order_V1_ReasonApi: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ReasonApi"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.type) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Order_V1_ReasonApi, rhs: Order_V1_ReasonApi) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Order_V1_Reasons: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Reasons"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "reason"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.reason) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.reason.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.reason, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Order_V1_Reasons, rhs: Order_V1_Reasons) -> Bool {
    if lhs.reason != rhs.reason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Order_V1_Reason: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Reason"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "reason_id"),
    2: .same(proto: "reason"),
    3: .standard(proto: "reason_en"),
    4: .standard(proto: "reason_ja"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.reasonID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.reason) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.reasonEn) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.reasonJa) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.reasonID != 0 {
      try visitor.visitSingularInt32Field(value: self.reasonID, fieldNumber: 1)
    }
    if !self.reason.isEmpty {
      try visitor.visitSingularStringField(value: self.reason, fieldNumber: 2)
    }
    if !self.reasonEn.isEmpty {
      try visitor.visitSingularStringField(value: self.reasonEn, fieldNumber: 3)
    }
    if !self.reasonJa.isEmpty {
      try visitor.visitSingularStringField(value: self.reasonJa, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Order_V1_Reason, rhs: Order_V1_Reason) -> Bool {
    if lhs.reasonID != rhs.reasonID {return false}
    if lhs.reason != rhs.reason {return false}
    if lhs.reasonEn != rhs.reasonEn {return false}
    if lhs.reasonJa != rhs.reasonJa {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Order_V1_AuditApiCreate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AuditApiCreate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "order_refund_id"),
    2: .standard(proto: "audit_status"),
    3: .standard(proto: "addition_data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.orderRefundID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.auditStatus) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.additionData) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.orderRefundID != 0 {
      try visitor.visitSingularInt64Field(value: self.orderRefundID, fieldNumber: 1)
    }
    if !self.auditStatus.isEmpty {
      try visitor.visitSingularStringField(value: self.auditStatus, fieldNumber: 2)
    }
    if !self.additionData.isEmpty {
      try visitor.visitSingularStringField(value: self.additionData, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Order_V1_AuditApiCreate, rhs: Order_V1_AuditApiCreate) -> Bool {
    if lhs.orderRefundID != rhs.orderRefundID {return false}
    if lhs.auditStatus != rhs.auditStatus {return false}
    if lhs.additionData != rhs.additionData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Order_V1_Audit: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Audit"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Order_V1_Audit, rhs: Order_V1_Audit) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Order_V1_RefundApiList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RefundApiList"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "order_id"),
    2: .standard(proto: "order_refund_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedInt64Field(value: &self.orderID) }()
      case 2: try { try decoder.decodeRepeatedInt64Field(value: &self.orderRefundID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.orderID.isEmpty {
      try visitor.visitPackedInt64Field(value: self.orderID, fieldNumber: 1)
    }
    if !self.orderRefundID.isEmpty {
      try visitor.visitPackedInt64Field(value: self.orderRefundID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Order_V1_RefundApiList, rhs: Order_V1_RefundApiList) -> Bool {
    if lhs.orderID != rhs.orderID {return false}
    if lhs.orderRefundID != rhs.orderRefundID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Order_V1_RefundList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RefundList"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "refund_list"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.refundList) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.refundList.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.refundList, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Order_V1_RefundList, rhs: Order_V1_RefundList) -> Bool {
    if lhs.refundList != rhs.refundList {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Order_V1_PartRefundApiCreate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PartRefundApiCreate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "order_id"),
    2: .standard(proto: "sub_order"),
    3: .standard(proto: "order_refund_id"),
    5: .same(proto: "remark"),
    6: .standard(proto: "reason_id"),
    7: .standard(proto: "addition_data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.orderID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.subOrder) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.orderRefundID) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.remark) }()
      case 6: try { try decoder.decodeRepeatedInt32Field(value: &self.reasonID) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.additionData) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.orderID != 0 {
      try visitor.visitSingularInt64Field(value: self.orderID, fieldNumber: 1)
    }
    if !self.subOrder.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.subOrder, fieldNumber: 2)
    }
    if self.orderRefundID != 0 {
      try visitor.visitSingularInt64Field(value: self.orderRefundID, fieldNumber: 3)
    }
    if !self.remark.isEmpty {
      try visitor.visitSingularStringField(value: self.remark, fieldNumber: 5)
    }
    if !self.reasonID.isEmpty {
      try visitor.visitPackedInt32Field(value: self.reasonID, fieldNumber: 6)
    }
    if !self.additionData.isEmpty {
      try visitor.visitSingularStringField(value: self.additionData, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Order_V1_PartRefundApiCreate, rhs: Order_V1_PartRefundApiCreate) -> Bool {
    if lhs.orderID != rhs.orderID {return false}
    if lhs.subOrder != rhs.subOrder {return false}
    if lhs.orderRefundID != rhs.orderRefundID {return false}
    if lhs.remark != rhs.remark {return false}
    if lhs.reasonID != rhs.reasonID {return false}
    if lhs.additionData != rhs.additionData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Order_V1_PartRefundSubOrderApiCreate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PartRefundSubOrderApiCreate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .standard(proto: "sub_order_id"),
    4: .standard(proto: "order_goods_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.subOrderID) }()
      case 4: try { try decoder.decodeRepeatedInt64Field(value: &self.orderGoodsID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.subOrderID != 0 {
      try visitor.visitSingularInt64Field(value: self.subOrderID, fieldNumber: 2)
    }
    if !self.orderGoodsID.isEmpty {
      try visitor.visitPackedInt64Field(value: self.orderGoodsID, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Order_V1_PartRefundSubOrderApiCreate, rhs: Order_V1_PartRefundSubOrderApiCreate) -> Bool {
    if lhs.subOrderID != rhs.subOrderID {return false}
    if lhs.orderGoodsID != rhs.orderGoodsID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Order_V1_FullRefundApiCreate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FullRefundApiCreate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "order_id"),
    2: .standard(proto: "sub_order_id"),
    3: .standard(proto: "order_refund_id"),
    4: .same(proto: "remark"),
    5: .standard(proto: "reason_id"),
    6: .standard(proto: "addition_data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.orderID) }()
      case 2: try { try decoder.decodeRepeatedInt64Field(value: &self.subOrderID) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.orderRefundID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.remark) }()
      case 5: try { try decoder.decodeRepeatedInt32Field(value: &self.reasonID) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.additionData) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.orderID != 0 {
      try visitor.visitSingularInt64Field(value: self.orderID, fieldNumber: 1)
    }
    if !self.subOrderID.isEmpty {
      try visitor.visitPackedInt64Field(value: self.subOrderID, fieldNumber: 2)
    }
    if self.orderRefundID != 0 {
      try visitor.visitSingularInt64Field(value: self.orderRefundID, fieldNumber: 3)
    }
    if !self.remark.isEmpty {
      try visitor.visitSingularStringField(value: self.remark, fieldNumber: 4)
    }
    if !self.reasonID.isEmpty {
      try visitor.visitPackedInt32Field(value: self.reasonID, fieldNumber: 5)
    }
    if !self.additionData.isEmpty {
      try visitor.visitSingularStringField(value: self.additionData, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Order_V1_FullRefundApiCreate, rhs: Order_V1_FullRefundApiCreate) -> Bool {
    if lhs.orderID != rhs.orderID {return false}
    if lhs.subOrderID != rhs.subOrderID {return false}
    if lhs.orderRefundID != rhs.orderRefundID {return false}
    if lhs.remark != rhs.remark {return false}
    if lhs.reasonID != rhs.reasonID {return false}
    if lhs.additionData != rhs.additionData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Order_V1_Refund: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Refund"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "order_id"),
    2: .standard(proto: "refund_sub_orders"),
    3: .same(proto: "currency"),
    4: .standard(proto: "order_refund_id"),
    5: .same(proto: "biz"),
    6: .standard(proto: "country_id"),
    7: .standard(proto: "city_id"),
    8: .standard(proto: "user_id"),
    9: .same(proto: "uid"),
    10: .standard(proto: "refund_status"),
    20: .standard(proto: "audit_status"),
    11: .standard(proto: "refund_amount"),
    21: .standard(proto: "refund_user_transaction_fee"),
    12: .same(proto: "remark"),
    13: .standard(proto: "refund_success_time"),
    14: .standard(proto: "refund_success_time_local"),
    15: .standard(proto: "refund_addition_fee"),
    16: .standard(proto: "refund_discount_fee"),
    17: .standard(proto: "created_at"),
    18: .standard(proto: "created_at_local"),
    19: .standard(proto: "addition_data"),
    22: .standard(proto: "audit_addition_data"),
    23: .same(proto: "reason"),
  ]

  fileprivate class _StorageClass {
    var _orderID: Int64 = 0
    var _refundSubOrders: [Order_V1_RefundSubOrder] = []
    var _currency: String = String()
    var _orderRefundID: Int64 = 0
    var _biz: String = String()
    var _countryID: Int32 = 0
    var _cityID: Int32 = 0
    var _userID: Int32 = 0
    var _uid: String = String()
    var _refundStatus: String = String()
    var _auditStatus: String = String()
    var _refundAmount: Double = 0
    var _refundUserTransactionFee: Double = 0
    var _remark: String = String()
    var _refundSuccessTime: Int64 = 0
    var _refundSuccessTimeLocal: String = String()
    var _refundAdditionFee: [Order_V1_RefundOrderAdditionFee] = []
    var _refundDiscountFee: [Order_V1_RefundOrderDiscountFee] = []
    var _createdAt: Int64 = 0
    var _createdAtLocal: String = String()
    var _additionData: String = String()
    var _auditAdditionData: String = String()
    var _reason: [Order_V1_Reason] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _orderID = source._orderID
      _refundSubOrders = source._refundSubOrders
      _currency = source._currency
      _orderRefundID = source._orderRefundID
      _biz = source._biz
      _countryID = source._countryID
      _cityID = source._cityID
      _userID = source._userID
      _uid = source._uid
      _refundStatus = source._refundStatus
      _auditStatus = source._auditStatus
      _refundAmount = source._refundAmount
      _refundUserTransactionFee = source._refundUserTransactionFee
      _remark = source._remark
      _refundSuccessTime = source._refundSuccessTime
      _refundSuccessTimeLocal = source._refundSuccessTimeLocal
      _refundAdditionFee = source._refundAdditionFee
      _refundDiscountFee = source._refundDiscountFee
      _createdAt = source._createdAt
      _createdAtLocal = source._createdAtLocal
      _additionData = source._additionData
      _auditAdditionData = source._auditAdditionData
      _reason = source._reason
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularInt64Field(value: &_storage._orderID) }()
        case 2: try { try decoder.decodeRepeatedMessageField(value: &_storage._refundSubOrders) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._currency) }()
        case 4: try { try decoder.decodeSingularInt64Field(value: &_storage._orderRefundID) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._biz) }()
        case 6: try { try decoder.decodeSingularInt32Field(value: &_storage._countryID) }()
        case 7: try { try decoder.decodeSingularInt32Field(value: &_storage._cityID) }()
        case 8: try { try decoder.decodeSingularInt32Field(value: &_storage._userID) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._uid) }()
        case 10: try { try decoder.decodeSingularStringField(value: &_storage._refundStatus) }()
        case 11: try { try decoder.decodeSingularDoubleField(value: &_storage._refundAmount) }()
        case 12: try { try decoder.decodeSingularStringField(value: &_storage._remark) }()
        case 13: try { try decoder.decodeSingularInt64Field(value: &_storage._refundSuccessTime) }()
        case 14: try { try decoder.decodeSingularStringField(value: &_storage._refundSuccessTimeLocal) }()
        case 15: try { try decoder.decodeRepeatedMessageField(value: &_storage._refundAdditionFee) }()
        case 16: try { try decoder.decodeRepeatedMessageField(value: &_storage._refundDiscountFee) }()
        case 17: try { try decoder.decodeSingularInt64Field(value: &_storage._createdAt) }()
        case 18: try { try decoder.decodeSingularStringField(value: &_storage._createdAtLocal) }()
        case 19: try { try decoder.decodeSingularStringField(value: &_storage._additionData) }()
        case 20: try { try decoder.decodeSingularStringField(value: &_storage._auditStatus) }()
        case 21: try { try decoder.decodeSingularDoubleField(value: &_storage._refundUserTransactionFee) }()
        case 22: try { try decoder.decodeSingularStringField(value: &_storage._auditAdditionData) }()
        case 23: try { try decoder.decodeRepeatedMessageField(value: &_storage._reason) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._orderID != 0 {
        try visitor.visitSingularInt64Field(value: _storage._orderID, fieldNumber: 1)
      }
      if !_storage._refundSubOrders.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._refundSubOrders, fieldNumber: 2)
      }
      if !_storage._currency.isEmpty {
        try visitor.visitSingularStringField(value: _storage._currency, fieldNumber: 3)
      }
      if _storage._orderRefundID != 0 {
        try visitor.visitSingularInt64Field(value: _storage._orderRefundID, fieldNumber: 4)
      }
      if !_storage._biz.isEmpty {
        try visitor.visitSingularStringField(value: _storage._biz, fieldNumber: 5)
      }
      if _storage._countryID != 0 {
        try visitor.visitSingularInt32Field(value: _storage._countryID, fieldNumber: 6)
      }
      if _storage._cityID != 0 {
        try visitor.visitSingularInt32Field(value: _storage._cityID, fieldNumber: 7)
      }
      if _storage._userID != 0 {
        try visitor.visitSingularInt32Field(value: _storage._userID, fieldNumber: 8)
      }
      if !_storage._uid.isEmpty {
        try visitor.visitSingularStringField(value: _storage._uid, fieldNumber: 9)
      }
      if !_storage._refundStatus.isEmpty {
        try visitor.visitSingularStringField(value: _storage._refundStatus, fieldNumber: 10)
      }
      if _storage._refundAmount != 0 {
        try visitor.visitSingularDoubleField(value: _storage._refundAmount, fieldNumber: 11)
      }
      if !_storage._remark.isEmpty {
        try visitor.visitSingularStringField(value: _storage._remark, fieldNumber: 12)
      }
      if _storage._refundSuccessTime != 0 {
        try visitor.visitSingularInt64Field(value: _storage._refundSuccessTime, fieldNumber: 13)
      }
      if !_storage._refundSuccessTimeLocal.isEmpty {
        try visitor.visitSingularStringField(value: _storage._refundSuccessTimeLocal, fieldNumber: 14)
      }
      if !_storage._refundAdditionFee.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._refundAdditionFee, fieldNumber: 15)
      }
      if !_storage._refundDiscountFee.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._refundDiscountFee, fieldNumber: 16)
      }
      if _storage._createdAt != 0 {
        try visitor.visitSingularInt64Field(value: _storage._createdAt, fieldNumber: 17)
      }
      if !_storage._createdAtLocal.isEmpty {
        try visitor.visitSingularStringField(value: _storage._createdAtLocal, fieldNumber: 18)
      }
      if !_storage._additionData.isEmpty {
        try visitor.visitSingularStringField(value: _storage._additionData, fieldNumber: 19)
      }
      if !_storage._auditStatus.isEmpty {
        try visitor.visitSingularStringField(value: _storage._auditStatus, fieldNumber: 20)
      }
      if _storage._refundUserTransactionFee != 0 {
        try visitor.visitSingularDoubleField(value: _storage._refundUserTransactionFee, fieldNumber: 21)
      }
      if !_storage._auditAdditionData.isEmpty {
        try visitor.visitSingularStringField(value: _storage._auditAdditionData, fieldNumber: 22)
      }
      if !_storage._reason.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._reason, fieldNumber: 23)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Order_V1_Refund, rhs: Order_V1_Refund) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._orderID != rhs_storage._orderID {return false}
        if _storage._refundSubOrders != rhs_storage._refundSubOrders {return false}
        if _storage._currency != rhs_storage._currency {return false}
        if _storage._orderRefundID != rhs_storage._orderRefundID {return false}
        if _storage._biz != rhs_storage._biz {return false}
        if _storage._countryID != rhs_storage._countryID {return false}
        if _storage._cityID != rhs_storage._cityID {return false}
        if _storage._userID != rhs_storage._userID {return false}
        if _storage._uid != rhs_storage._uid {return false}
        if _storage._refundStatus != rhs_storage._refundStatus {return false}
        if _storage._auditStatus != rhs_storage._auditStatus {return false}
        if _storage._refundAmount != rhs_storage._refundAmount {return false}
        if _storage._refundUserTransactionFee != rhs_storage._refundUserTransactionFee {return false}
        if _storage._remark != rhs_storage._remark {return false}
        if _storage._refundSuccessTime != rhs_storage._refundSuccessTime {return false}
        if _storage._refundSuccessTimeLocal != rhs_storage._refundSuccessTimeLocal {return false}
        if _storage._refundAdditionFee != rhs_storage._refundAdditionFee {return false}
        if _storage._refundDiscountFee != rhs_storage._refundDiscountFee {return false}
        if _storage._createdAt != rhs_storage._createdAt {return false}
        if _storage._createdAtLocal != rhs_storage._createdAtLocal {return false}
        if _storage._additionData != rhs_storage._additionData {return false}
        if _storage._auditAdditionData != rhs_storage._auditAdditionData {return false}
        if _storage._reason != rhs_storage._reason {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Order_V1_RefundSubOrder: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RefundSubOrder"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "sub_order_id"),
    2: .standard(proto: "order_refund_id"),
    3: .standard(proto: "refund_status"),
    4: .standard(proto: "refund_amount"),
    5: .same(proto: "remark"),
    6: .standard(proto: "refund_success_time"),
    7: .standard(proto: "refund_success_time_local"),
    8: .standard(proto: "refund_items"),
    15: .standard(proto: "refund_addition_fee"),
    16: .standard(proto: "refund_discount_fee"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.subOrderID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.orderRefundID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.refundStatus) }()
      case 4: try { try decoder.decodeSingularDoubleField(value: &self.refundAmount) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.remark) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.refundSuccessTime) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.refundSuccessTimeLocal) }()
      case 8: try { try decoder.decodeRepeatedMessageField(value: &self.refundItems) }()
      case 15: try { try decoder.decodeRepeatedMessageField(value: &self.refundAdditionFee) }()
      case 16: try { try decoder.decodeRepeatedMessageField(value: &self.refundDiscountFee) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.subOrderID != 0 {
      try visitor.visitSingularInt64Field(value: self.subOrderID, fieldNumber: 1)
    }
    if self.orderRefundID != 0 {
      try visitor.visitSingularInt64Field(value: self.orderRefundID, fieldNumber: 2)
    }
    if !self.refundStatus.isEmpty {
      try visitor.visitSingularStringField(value: self.refundStatus, fieldNumber: 3)
    }
    if self.refundAmount != 0 {
      try visitor.visitSingularDoubleField(value: self.refundAmount, fieldNumber: 4)
    }
    if !self.remark.isEmpty {
      try visitor.visitSingularStringField(value: self.remark, fieldNumber: 5)
    }
    if self.refundSuccessTime != 0 {
      try visitor.visitSingularInt64Field(value: self.refundSuccessTime, fieldNumber: 6)
    }
    if !self.refundSuccessTimeLocal.isEmpty {
      try visitor.visitSingularStringField(value: self.refundSuccessTimeLocal, fieldNumber: 7)
    }
    if !self.refundItems.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.refundItems, fieldNumber: 8)
    }
    if !self.refundAdditionFee.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.refundAdditionFee, fieldNumber: 15)
    }
    if !self.refundDiscountFee.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.refundDiscountFee, fieldNumber: 16)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Order_V1_RefundSubOrder, rhs: Order_V1_RefundSubOrder) -> Bool {
    if lhs.subOrderID != rhs.subOrderID {return false}
    if lhs.orderRefundID != rhs.orderRefundID {return false}
    if lhs.refundStatus != rhs.refundStatus {return false}
    if lhs.refundAmount != rhs.refundAmount {return false}
    if lhs.remark != rhs.remark {return false}
    if lhs.refundSuccessTime != rhs.refundSuccessTime {return false}
    if lhs.refundSuccessTimeLocal != rhs.refundSuccessTimeLocal {return false}
    if lhs.refundItems != rhs.refundItems {return false}
    if lhs.refundAdditionFee != rhs.refundAdditionFee {return false}
    if lhs.refundDiscountFee != rhs.refundDiscountFee {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Order_V1_RefundOrderItem: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RefundOrderItem"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    4: .standard(proto: "order_refund_id"),
    1: .standard(proto: "order_item_id"),
    2: .standard(proto: "item_name"),
    9: .standard(proto: "refund_status"),
    10: .standard(proto: "refund_amount"),
    11: .same(proto: "remark"),
    12: .standard(proto: "refund_success_time"),
    13: .standard(proto: "refund_success_time_local"),
    3: .standard(proto: "refund_goods"),
    15: .standard(proto: "refund_addition_fee"),
    16: .standard(proto: "refund_discount_fee"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.orderItemID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.itemName) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.refundGoods) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.orderRefundID) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.refundStatus) }()
      case 10: try { try decoder.decodeSingularDoubleField(value: &self.refundAmount) }()
      case 11: try { try decoder.decodeSingularStringField(value: &self.remark) }()
      case 12: try { try decoder.decodeSingularInt64Field(value: &self.refundSuccessTime) }()
      case 13: try { try decoder.decodeSingularStringField(value: &self.refundSuccessTimeLocal) }()
      case 15: try { try decoder.decodeRepeatedMessageField(value: &self.refundAdditionFee) }()
      case 16: try { try decoder.decodeRepeatedMessageField(value: &self.refundDiscountFee) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.orderItemID != 0 {
      try visitor.visitSingularInt64Field(value: self.orderItemID, fieldNumber: 1)
    }
    if !self.itemName.isEmpty {
      try visitor.visitSingularStringField(value: self.itemName, fieldNumber: 2)
    }
    if !self.refundGoods.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.refundGoods, fieldNumber: 3)
    }
    if self.orderRefundID != 0 {
      try visitor.visitSingularInt64Field(value: self.orderRefundID, fieldNumber: 4)
    }
    if !self.refundStatus.isEmpty {
      try visitor.visitSingularStringField(value: self.refundStatus, fieldNumber: 9)
    }
    if self.refundAmount != 0 {
      try visitor.visitSingularDoubleField(value: self.refundAmount, fieldNumber: 10)
    }
    if !self.remark.isEmpty {
      try visitor.visitSingularStringField(value: self.remark, fieldNumber: 11)
    }
    if self.refundSuccessTime != 0 {
      try visitor.visitSingularInt64Field(value: self.refundSuccessTime, fieldNumber: 12)
    }
    if !self.refundSuccessTimeLocal.isEmpty {
      try visitor.visitSingularStringField(value: self.refundSuccessTimeLocal, fieldNumber: 13)
    }
    if !self.refundAdditionFee.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.refundAdditionFee, fieldNumber: 15)
    }
    if !self.refundDiscountFee.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.refundDiscountFee, fieldNumber: 16)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Order_V1_RefundOrderItem, rhs: Order_V1_RefundOrderItem) -> Bool {
    if lhs.orderRefundID != rhs.orderRefundID {return false}
    if lhs.orderItemID != rhs.orderItemID {return false}
    if lhs.itemName != rhs.itemName {return false}
    if lhs.refundStatus != rhs.refundStatus {return false}
    if lhs.refundAmount != rhs.refundAmount {return false}
    if lhs.remark != rhs.remark {return false}
    if lhs.refundSuccessTime != rhs.refundSuccessTime {return false}
    if lhs.refundSuccessTimeLocal != rhs.refundSuccessTimeLocal {return false}
    if lhs.refundGoods != rhs.refundGoods {return false}
    if lhs.refundAdditionFee != rhs.refundAdditionFee {return false}
    if lhs.refundDiscountFee != rhs.refundDiscountFee {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Order_V1_RefundOrderGoods: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RefundOrderGoods"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    4: .standard(proto: "order_refund_id"),
    1: .standard(proto: "order_goods_id"),
    2: .standard(proto: "goods_id"),
    19: .standard(proto: "biz_order_goods_id"),
    3: .standard(proto: "goods_name"),
    9: .standard(proto: "refund_status"),
    10: .standard(proto: "refund_amount"),
    17: .standard(proto: "refund_origin_amount"),
    18: .standard(proto: "refund_user_transaction_fee"),
    11: .same(proto: "remark"),
    12: .standard(proto: "refund_success_time"),
    13: .standard(proto: "refund_success_time_local"),
    15: .standard(proto: "refund_addition_fee"),
    16: .standard(proto: "refund_discount_fee"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.orderGoodsID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.goodsID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.goodsName) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.orderRefundID) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.refundStatus) }()
      case 10: try { try decoder.decodeSingularDoubleField(value: &self.refundAmount) }()
      case 11: try { try decoder.decodeSingularStringField(value: &self.remark) }()
      case 12: try { try decoder.decodeSingularInt64Field(value: &self.refundSuccessTime) }()
      case 13: try { try decoder.decodeSingularStringField(value: &self.refundSuccessTimeLocal) }()
      case 15: try { try decoder.decodeRepeatedMessageField(value: &self.refundAdditionFee) }()
      case 16: try { try decoder.decodeRepeatedMessageField(value: &self.refundDiscountFee) }()
      case 17: try { try decoder.decodeSingularDoubleField(value: &self.refundOriginAmount) }()
      case 18: try { try decoder.decodeSingularDoubleField(value: &self.refundUserTransactionFee) }()
      case 19: try { try decoder.decodeSingularStringField(value: &self.bizOrderGoodsID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.orderGoodsID != 0 {
      try visitor.visitSingularInt64Field(value: self.orderGoodsID, fieldNumber: 1)
    }
    if !self.goodsID.isEmpty {
      try visitor.visitSingularStringField(value: self.goodsID, fieldNumber: 2)
    }
    if !self.goodsName.isEmpty {
      try visitor.visitSingularStringField(value: self.goodsName, fieldNumber: 3)
    }
    if self.orderRefundID != 0 {
      try visitor.visitSingularInt64Field(value: self.orderRefundID, fieldNumber: 4)
    }
    if !self.refundStatus.isEmpty {
      try visitor.visitSingularStringField(value: self.refundStatus, fieldNumber: 9)
    }
    if self.refundAmount != 0 {
      try visitor.visitSingularDoubleField(value: self.refundAmount, fieldNumber: 10)
    }
    if !self.remark.isEmpty {
      try visitor.visitSingularStringField(value: self.remark, fieldNumber: 11)
    }
    if self.refundSuccessTime != 0 {
      try visitor.visitSingularInt64Field(value: self.refundSuccessTime, fieldNumber: 12)
    }
    if !self.refundSuccessTimeLocal.isEmpty {
      try visitor.visitSingularStringField(value: self.refundSuccessTimeLocal, fieldNumber: 13)
    }
    if !self.refundAdditionFee.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.refundAdditionFee, fieldNumber: 15)
    }
    if !self.refundDiscountFee.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.refundDiscountFee, fieldNumber: 16)
    }
    if self.refundOriginAmount != 0 {
      try visitor.visitSingularDoubleField(value: self.refundOriginAmount, fieldNumber: 17)
    }
    if self.refundUserTransactionFee != 0 {
      try visitor.visitSingularDoubleField(value: self.refundUserTransactionFee, fieldNumber: 18)
    }
    if !self.bizOrderGoodsID.isEmpty {
      try visitor.visitSingularStringField(value: self.bizOrderGoodsID, fieldNumber: 19)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Order_V1_RefundOrderGoods, rhs: Order_V1_RefundOrderGoods) -> Bool {
    if lhs.orderRefundID != rhs.orderRefundID {return false}
    if lhs.orderGoodsID != rhs.orderGoodsID {return false}
    if lhs.goodsID != rhs.goodsID {return false}
    if lhs.bizOrderGoodsID != rhs.bizOrderGoodsID {return false}
    if lhs.goodsName != rhs.goodsName {return false}
    if lhs.refundStatus != rhs.refundStatus {return false}
    if lhs.refundAmount != rhs.refundAmount {return false}
    if lhs.refundOriginAmount != rhs.refundOriginAmount {return false}
    if lhs.refundUserTransactionFee != rhs.refundUserTransactionFee {return false}
    if lhs.remark != rhs.remark {return false}
    if lhs.refundSuccessTime != rhs.refundSuccessTime {return false}
    if lhs.refundSuccessTimeLocal != rhs.refundSuccessTimeLocal {return false}
    if lhs.refundAdditionFee != rhs.refundAdditionFee {return false}
    if lhs.refundDiscountFee != rhs.refundDiscountFee {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Order_V1_RefundOrderAdditionFee: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RefundOrderAdditionFee"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "title"),
    2: .standard(proto: "addition_type"),
    3: .standard(proto: "order_id"),
    4: .standard(proto: "sub_order_id"),
    5: .standard(proto: "order_item_id"),
    6: .standard(proto: "order_goods_id"),
    7: .standard(proto: "platform_fee"),
    8: .standard(proto: "merchant_fee"),
    9: .standard(proto: "addition_amount"),
    10: .standard(proto: "addition_data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.additionType) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.orderID) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.subOrderID) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.orderItemID) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.orderGoodsID) }()
      case 7: try { try decoder.decodeSingularDoubleField(value: &self.platformFee) }()
      case 8: try { try decoder.decodeSingularDoubleField(value: &self.merchantFee) }()
      case 9: try { try decoder.decodeSingularDoubleField(value: &self.additionAmount) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self.additionData) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 1)
    }
    if !self.additionType.isEmpty {
      try visitor.visitSingularStringField(value: self.additionType, fieldNumber: 2)
    }
    if self.orderID != 0 {
      try visitor.visitSingularInt64Field(value: self.orderID, fieldNumber: 3)
    }
    if self.subOrderID != 0 {
      try visitor.visitSingularInt64Field(value: self.subOrderID, fieldNumber: 4)
    }
    if self.orderItemID != 0 {
      try visitor.visitSingularInt64Field(value: self.orderItemID, fieldNumber: 5)
    }
    if self.orderGoodsID != 0 {
      try visitor.visitSingularInt64Field(value: self.orderGoodsID, fieldNumber: 6)
    }
    if self.platformFee != 0 {
      try visitor.visitSingularDoubleField(value: self.platformFee, fieldNumber: 7)
    }
    if self.merchantFee != 0 {
      try visitor.visitSingularDoubleField(value: self.merchantFee, fieldNumber: 8)
    }
    if self.additionAmount != 0 {
      try visitor.visitSingularDoubleField(value: self.additionAmount, fieldNumber: 9)
    }
    if !self.additionData.isEmpty {
      try visitor.visitSingularStringField(value: self.additionData, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Order_V1_RefundOrderAdditionFee, rhs: Order_V1_RefundOrderAdditionFee) -> Bool {
    if lhs.title != rhs.title {return false}
    if lhs.additionType != rhs.additionType {return false}
    if lhs.orderID != rhs.orderID {return false}
    if lhs.subOrderID != rhs.subOrderID {return false}
    if lhs.orderItemID != rhs.orderItemID {return false}
    if lhs.orderGoodsID != rhs.orderGoodsID {return false}
    if lhs.platformFee != rhs.platformFee {return false}
    if lhs.merchantFee != rhs.merchantFee {return false}
    if lhs.additionAmount != rhs.additionAmount {return false}
    if lhs.additionData != rhs.additionData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Order_V1_RefundOrderDiscountFee: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RefundOrderDiscountFee"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "title"),
    2: .standard(proto: "discount_type"),
    3: .standard(proto: "order_id"),
    4: .standard(proto: "sub_order_id"),
    5: .standard(proto: "order_item_id"),
    6: .standard(proto: "order_goods_id"),
    7: .standard(proto: "platform_fee"),
    8: .standard(proto: "merchant_fee"),
    9: .standard(proto: "discount_amount"),
    12: .standard(proto: "addition_data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.discountType) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.orderID) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.subOrderID) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.orderItemID) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.orderGoodsID) }()
      case 7: try { try decoder.decodeSingularDoubleField(value: &self.platformFee) }()
      case 8: try { try decoder.decodeSingularDoubleField(value: &self.merchantFee) }()
      case 9: try { try decoder.decodeSingularDoubleField(value: &self.discountAmount) }()
      case 12: try { try decoder.decodeSingularStringField(value: &self.additionData) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 1)
    }
    if !self.discountType.isEmpty {
      try visitor.visitSingularStringField(value: self.discountType, fieldNumber: 2)
    }
    if self.orderID != 0 {
      try visitor.visitSingularInt64Field(value: self.orderID, fieldNumber: 3)
    }
    if self.subOrderID != 0 {
      try visitor.visitSingularInt64Field(value: self.subOrderID, fieldNumber: 4)
    }
    if self.orderItemID != 0 {
      try visitor.visitSingularInt64Field(value: self.orderItemID, fieldNumber: 5)
    }
    if self.orderGoodsID != 0 {
      try visitor.visitSingularInt64Field(value: self.orderGoodsID, fieldNumber: 6)
    }
    if self.platformFee != 0 {
      try visitor.visitSingularDoubleField(value: self.platformFee, fieldNumber: 7)
    }
    if self.merchantFee != 0 {
      try visitor.visitSingularDoubleField(value: self.merchantFee, fieldNumber: 8)
    }
    if self.discountAmount != 0 {
      try visitor.visitSingularDoubleField(value: self.discountAmount, fieldNumber: 9)
    }
    if !self.additionData.isEmpty {
      try visitor.visitSingularStringField(value: self.additionData, fieldNumber: 12)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Order_V1_RefundOrderDiscountFee, rhs: Order_V1_RefundOrderDiscountFee) -> Bool {
    if lhs.title != rhs.title {return false}
    if lhs.discountType != rhs.discountType {return false}
    if lhs.orderID != rhs.orderID {return false}
    if lhs.subOrderID != rhs.subOrderID {return false}
    if lhs.orderItemID != rhs.orderItemID {return false}
    if lhs.orderGoodsID != rhs.orderGoodsID {return false}
    if lhs.platformFee != rhs.platformFee {return false}
    if lhs.merchantFee != rhs.merchantFee {return false}
    if lhs.discountAmount != rhs.discountAmount {return false}
    if lhs.additionData != rhs.additionData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
