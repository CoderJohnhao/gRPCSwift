## 1、gRPC

​	gRPC 是一种现代开源高性能远程过程调用 (RPC) 框架，可以在任何环境中运行。 它可以通过对负载平衡、跟踪、健康检查和身份验证的可插拔支持，有效地连接数据中心内和数据中心之间的服务。 它还适用于分布式计算的最后一英里，将设备、移动应用程序和浏览器连接到后端服务。 支持Go、C++、Java、Python、C#、Dart、Kotlin、Node、OC、Swift、PHP、Ruby等编程语言。	

​	在 gRPC 中，客户端应用程序可以直接调用不同机器上的服务器应用程序上的方法，就像它是本地对象一样，使您可以更轻松地创建分布式应用程序和服务。与许多 RPC 系统一样，gRPC 基于定义服务的思想，指定可以通过参数和返回类型远程调用的方法。在服务器端，服务器实现了这个接口并运行一个 gRPC 服务器来处理客户端调用。在客户端，客户端有一个存根（在某些语言中简称为客户端），它提供与服务器相同的方法。

![https://grpc.io/img/landing-2.svg](https://grpc.io/img/landing-2.svg)

默认情况下，gRPC 使用protocol buffer，是 Google 语言中立、平台中立、可扩展序列化结构化数据的可扩展机制一种XML，但是更小、更快、更简单。您可以一次定义数据的结构化方式，然后您可以使用特殊生成的源代码轻松地使用各种语言、各种数据流中写入和读取结构化数据。

## 2、安装proto/grpc插件

##### 1、使用pod安装Swift-proto/gprc插件

```swift
pod 'gRPC-Swift'
pod 'gRPC-Swift-Plugins'
// 执行pod install
$pod install

//pod install完成后，将Pods/gRPC-Swift-Plugins里面的protoc-gen-swift/protoc-gen-grpc-swift 拷贝到/usr/local/bin
$cp protoc-gen-swift protoc-gen-grpc-swift /usr/local/bin
```

##### 2、安装OC-proto/grpc插件

- 新建一个.podspec文件

```ruby
Pod::Spec.new do |s|
  s.name     = '<Podspec file name>'
  s.version  = '0.0.1'
  s.license  = '...'
  s.authors  = { '<your name>' => '<your email>' }
  s.homepage = '...'
  s.summary = '...'
  s.source = { :git => 'https://github.com/...' }

  s.ios.deployment_target = '9.0'
  s.osx.deployment_target = '10.10'

  # Base directory where the .proto files are.
  src = '.'

  # We'll use protoc with the gRPC plugin.
  s.dependency '!ProtoCompiler-gRPCPlugin', '~> 1.0'

  # Pods directory corresponding to this app's Podfile, relative to the location of this podspec.
  pods_root = '<path to your Podfile>/Pods'

  # Path where Cocoapods downloads protoc and the gRPC plugin.
  protoc_dir = "#{pods_root}/!ProtoCompiler"
  protoc = "#{protoc_dir}/protoc"
  plugin = "#{pods_root}/!ProtoCompiler-gRPCPlugin/grpc_objective_c_plugin"

  # Directory where you want the generated files to be placed. This is an example.
  dir = "#{pods_root}/#{s.name}"

  # Run protoc with the Objective-C and gRPC plugins to generate protocol messages and gRPC clients.
  # You can run this command manually if you later change your protos and need to regenerate.
  # Alternatively, you can advance the version of this podspec and run `pod update`.
  s.prepare_command = <<-CMD
    mkdir -p #{dir}
    #{protoc} \
        --plugin=protoc-gen-grpc=#{plugin} \
        --objc_out=#{dir} \
        --grpc_out=#{dir} \
        -I #{src} \
        -I #{protoc_dir} \
        #{src}/*.proto
  CMD

  # The --objc_out plugin generates a pair of .pbobjc.h/.pbobjc.m files for each .proto file.
  s.subspec 'Messages' do |ms|
    ms.source_files = "#{dir}/*.pbobjc.{h,m}"
    ms.header_mappings_dir = dir
    ms.requires_arc = false
    # The generated files depend on the protobuf runtime.
    ms.dependency 'Protobuf'
  end

  # The --objcgrpc_out plugin generates a pair of .pbrpc.h/.pbrpc.m files for each .proto file with
  # a service defined.
  s.subspec 'Services' do |ss|
    ss.source_files = "#{dir}/*.pbrpc.{h,m}"
    ss.header_mappings_dir = dir
    ss.requires_arc = true
    # The generated files depend on the gRPC runtime, and on the files generated by `--objc_out`.
    ss.dependency 'gRPC-ProtoRPC'
    ss.dependency "#{s.name}/Messages"
  end

  s.pod_target_xcconfig = {
    # This is needed by all pods that depend on Protobuf:
    'GCC_PREPROCESSOR_DEFINITIONS' => '$(inherited) GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS=1',
    # This is needed by all pods that depend on gRPC-RxLibrary:
    'CLANG_ALLOW_NON_MODULAR_INCLUDES_IN_FRAMEWORK_MODULES' => 'YES',
  }
end

// 新建Podfile文件
pod '<Podspec file name>', :path => 'podspec文件路径'

// 再执行 pod install
```

##### 3、服务端使用python语言，python安装protoc/grpc插件

```
$python -m pip install grpcio
$python -m pip install grpcio-tools googleapis-common-protos
```

## 3、生成Protobuf协议对应编程语言文件

生成终端命令

```swift
// swift 
protoc (.proto文件路径) --swift_out=.(生成文件的路径，如果生成在当前文件目录之间".") --grpc-swift_out=Client=true,Server=false:.(生成文件的路径，如果生成在当前文件目录之间".")
// oc
protoc --proto_path=. --objc_out=. 文件.proto
```

## 4、proto语法

使用的proto语法的文本文件, 用来定义数据格式。

##### 1、自定义消息类型

###### 1.0、下面是一个简单的例子：

```protobuf
syntax="proto3"; // proto版本

// 请求
message HelloRequest {
	// 类型 名称 = 编号;
	string name = 1;
}
```

- 第一行的含义是定该文件使用的是proto3的语法。

- HelloRequest定义有一个承载消息的属性，每一个被定义在HelloRequest消息体中的字段，都是由数据类型和属性名称组成。

###### 1.1、指定字段类型

​	在上面的示例中，字段是标量类型：字符串类型(name)，但是您也可以为字段指定复合类型，包括枚举和其他消息类型。

###### 1.2、分配数字编号

​	消息定义中的每个字段都有一个**唯一的编号**。这些字段编号用于在[消息二进制格式中](https://developers.google.com/protocol-buffers/docs/encoding)标识您的字段，一旦您的消息类型被使用，就不应更改。请注意，1 到 15 范围内的字段编号占用一个字节进行编码，包括字段编号和字段类型（您可以在[协议缓冲区编码中](https://developers.google.com/protocol-buffers/docs/encoding#structure)找到更多相关信息）。16 到 2047 范围内的字段编号占用两个字节。因此，您应该为非常频繁出现的消息元素保留数字 1 到 15。请记住为将来可能添加的频繁出现的元素留出一些空间。

###### 1.3、指定字段规则

​	消息字段可以是以下之一：

- singular：格式正确的消息可以有零个或一个此字段，这是 proto3 语法的默认字段规则。
- repeated：该字段可以在消息中重复任意次数，重复值的顺序将被保留。类似数组

###### 1.4、添加更多的消息类型

​	可以在单个`.proto`文件中定义多种消息类型。如果您要定义多个相关消息，这很有用 - 例如，如果您想定义与您的`HelloResponse`消息类型相对应的回复消息格式，您可以将其添加到相同的`.proto`

```protobuf
syntax="proto3"; // proto版本

// 请求
message HelloRequest {
	// 类型 名称 = 编号;
	string name = 1;
}

// 响应
message HelloResponse {
	string result = 1;
}
```

###### 1.5、添加评论

​	要向`.proto`文件添加注释，请使用 C/C++ 样式`//`和`/* ... */`语法。

```protobuf
syntax="proto3";

/* 这是注释 */
message HelloRequest {
	string name = 1; // 姓名
}
```

###### 1.6、保留字段

​	如果您通过完全删除某个字段或将其注释掉来[更新](https://developers.google.com/protocol-buffers/docs/proto3#updating)消息类型，则未来的用户可以在对类型进行自己的更新时重复使用该字段编号。如果他们以后加载相同的旧版本，这可能会导致严重的问题`.proto`，包括数据损坏、隐私错误等。确保不会发生这种情况的一种方法是指定已删除字段的字段编号是`reserved`. 如果任何未来的用户尝试使用这些字段标识符，协议缓冲区编译器会报错。请注意，您不能在同一`reserved`语句中混合使用字段名称和字段编号。

```protobuf
message Foo {
  reserved 2, 15, 9 to 11;
  reserved "foo", "bar";
  // reserved 2, "foo"; ❌
}
```

##### 2、数据类型

| proto    | Swift  | OC       |
| :------- | ------ | -------- |
| double   | Double | double   |
| float    | Float  | float    |
| int32    | Int32  | int32_t  |
| int64    | Int64  | int64_t  |
| uint32   | UInt32 | uint32_t |
| uint64   | UInt64 | uint64_t |
| sint32   | Int32  | int32_t  |
| sint64   | Int64  | int64_t  |
| fixed32  | UInt32 | uint32_t |
| fixed64  | UInt64 | uint64_t |
| sfixed32 | Int32  | int32_t  |
| sfixed64 | Int64  | int64_t  |
| bool     | Bool   | BOOL     |
| string   | String | NSString |
| bytes    | Data   | NSData   |

##### 3、默认值

​	解析消息时，如果编码的消息不包含特定的单数元素，则解析对象中的相应字段将设置为该字段的默认值。这些默认值是特定于类型的：

- 对于string，默认值为空字符串。
- 对于bytes，默认值为空字节。
- 对于 bool，默认值为 false。
- 对于数字类型，默认值为零。
- 对于[enums](https://developers.google.com/protocol-buffers/docs/proto3#enum)，默认值是第**一个定义的 enum value**，它必须是 0。
- 对于消息字段，未设置该字段。它的确切值取决于语言。有关详细信息，请参阅[生成的代码指南](https://developers.google.com/protocol-buffers/docs/reference/overview)。

##### 4、枚举

​	当您定义消息类型时，您可能希望它的一个字段只有一个预定义的值列表。例如，假设你想添加一个`corpus`字段每个`SearchRequest`，其中语料库可以`UNIVERSAL`，`WEB`，`IMAGES`，`LOCAL`，`NEWS`，`PRODUCTS`或`VIDEO`。您可以通过`enum`为每个可能的值添加一个常量到您的消息定义中来非常简单地做到这一点。在下面的示例中，我们添加了一个具有所有可能值的`enum`调用`Corpus`和一个类型为的字段`Corpus`：

```protobuf
message SearchRequest {
  string query = 1;
  int32 page_number = 2;
  int32 result_per_page = 3;
  enum Corpus {
    UNIVERSAL = 0;
    WEB = 1;
    IMAGES = 2;
    LOCAL = 3;
    NEWS = 4;
    PRODUCTS = 5;
    VIDEO = 6;
  }
  Corpus corpus = 4;
}
```

##### 5、使用其他类型

您可以使用其他消息类型作为字段类型。例如，假设您想`Result`在每条`SearchResponse`消息中包含消息,为此您可以在其中定义一个`Result`消息类型`.proto`，然后指定一个类型为`Result`in的字段`SearchResponse`：

```protobuf
import "其他类型文件相对路径.proto"; // Test
import "google/protobuf/any.proto";

message SearchResponse {
	// 引用当前文件内类型
  repeated Result results = 1;
  // 引用其他文件类型
  Test test = 2;
  // 使用包名，防止重名冲突
  test.bar.Result result = 3;
  // Map
  map<stirng, int> ages = 4;
  // Any
  google.protobuf.Any any1 = 5;
}

message Result {
  string url = 1;
  string title = 2;
  repeated string snippets = 3;
  
  message DataMsg {
  	string msg = 1;
  	string desc = 2;
  }
  // 内嵌
  DataMsg msg = 4;
}
```

```protobuf
package test.bar;
message Result {
	...
}
```

##### 6、定义服务Server

​	如果您想在 RPC（远程过程调用）系统中使用您的消息类型，您可以在`.proto`文件中定义一个 RPC 服务接口，协议缓冲区编译器将以您选择的语言生成服务接口代码和存根。因此，例如，如果您想使用接受您`HelloRequest`并返回 a的方法定义 RPC 服务`HelloResponse`，您可以在您的`.proto`文件中按如下方式定义它：

```protobuf
syntax = "proto3";

message HelloRequest {
	string name = 1; // 姓名
}

message HelloResponse {
	string result = 1;
}

service HelloServer {
	rpc Hello(HelloRequest) returns (HelloResponse);
}
```

## 5、Client-Swift实现

用.proto 文件来创建GRPC服务， 用Protobuf消息类型定义方法参数和返回类型，格式如下。

```protobuf
syntax = "proto3";

package helloworld;

message HelloRequest {
    string name = 1;
}

message HelloResponse {
    string result = 1;
}

service HelloServer {
    rpc Hello (HelloRequest) returns (HelloResponse) {}
}
```

终端cd 到.proto文件目录下，生成.pb.swfit和.grpc.swift两个文件

```
protoc .proto文件路径 \
    --proto_path=proto文件目录 \
    --plugin=protoc-gen-swift执行文件路径 \
    --swift_opt=Visibility=Public \
    --swift_out=生成.pb.swift存放目录 \
    --plugin=protoc-gen-grpc-swift执行文件路径 \
    --grpc-swift_opt=Visibility=Public \
    --grpc-swift_out=生成.grpc.swift存放目录
```

代码实现,demo链接[Github](https://github.com/CoderJohnhao/gRPCSwift.git)

```swift
import GRPC
import NIO
import Logging

/// 服务器地址
let host = "0.0.0.0"
/// 端口
let port = 5000

/// 创建一个事件循环组
/// - loopCount: 循环个数
let eventLoopGroup = PlatformSupport.makeEventLoopGroup(loopCount: 1)

// 设置连接间隔时间/超时时间
let keepalive = ClientConnectionKeepalive(interval: .seconds(15),
                                          timeout: .seconds(10))
// 设置logger
var logger = Logger(label: "gRPC", factory: StreamLogHandler.standardError(label:))
logger.logLevel = .debug

// 信道
let channel = ClientConnection
    .insecure(group: group) // 事件循环组
    .withKeepalive(keepalive) // 设置保持长连接时间
    .withBackgroundActivityLogger(logger)
    .connect(host: host, port: port)

// 创建一个链接
let client = Helloworld_HelloServerClient(channel: channel)
// 请求
let request = Helloworld_HelloRequest.with { $0.name = text }
// 发起请求
let call = client.hello(request)
call.response.whenCompleteBlocking(onto: .main) { [weak self] result in
    do {
        let response = try result.get()
        print(response.result)
    } catch {
        print(error.localizedDescription)
    }
    // 关闭                                            
    let _ = channel.close()
}
```



## 6、Client-OC实现

demo链接[Github](https://github.com/CoderJohnhao/gRPC-OC.git)

## 7、Server-Python实现

demo链接[Github](https://github.com/CoderJohnhao/grpcdemo.git)

